const e={config:{},parts:[],plates:[],errors:null,currentIndexPlate:0,symbols:{unusedSpace:0,rect:1,startSpace:2,alternateSpace:3,divide:4},statistic:{},sizeStep:null,countPart:null,maxIteration:100},t={_state:{},init(){this._state=e},getState(){return this._state},getErrors(){return{errors:this._state.errors}},setState(e){this._state={...this._state,...e}}};const a=function(e){const t=[];return[e.length,e.height,e.minPart].some((e=>!Number.isInteger(e)||e<=0))&&t.push("Element is not integer"),(e.maxStack<0||!Number.isInteger(e.maxStack))&&t.push("Max Stack is not valid"),(e.optimization<0||!Number.isInteger(e.optimization)||e.optimization>10)&&t.push("Optimization level is not valid"),e.parts.filter((e=>void 0===e.length||void 0===e.height||void 0===e.count||void 0===e.hem||void 0===e.edge||!Number.isInteger(e.length)||!Number.isInteger(e.height)||!Number.isInteger(e.count)||!Number.isInteger(e.hem)||!Number.isInteger(e.edge)||e.length<=0||e.height<=0||e.count<=0||e.hem<0||e.edge<0)).length&&t.push("Parts is not valid"),e.parts.filter((t=>t.length>e.length*(e.maxStack+1)||t.height>e.height-t.hem-t.edge||t.length<e.minPart||t.height<e.minPart)).length&&t.push("Parts is not valid (diapason)"),!Number.isNaN(e.step)&&[.1,.2,.25,.5,1].find((t=>t===e.step))||t.push("Step is not valid"),!0!==e.nameIsPrefix&&!1!==e.nameIsPrefix&&t.push("nameIsPrefix is not bool"),!0!==e.rotate&&!1!==e.rotate&&t.push("rotate is not bool"),!0!==e.cut&&!1!==e.cut&&t.push("cut is not bool"),!0!==e.showPartInName&&!1!==e.showPartInName&&t.push("showPartInName is not bool"),!0!==e.getAllData&&!1!==e.getAllData&&t.push("getAllData is not bool"),!0!==e.prepareOutputPlates&&!1!==e.prepareOutputPlates&&t.push("prepareOutputPlates is not bool"),!0!==e.axisX&&!1!==e.axisX&&t.push("axisX is not bool"),t};const r=function(e){return{name:e.name.toString(),partName:e.partName.toString(),length:+e.length,height:+e.height,step:+e.step,minPart:+e.minPart,maxStack:+e.maxStack,optimization:+e.optimization,parts:e.parts.map((e=>({...e,name:e.name,length:+e.length,height:+e.height+ +e.hem+ +e.edge,count:+e.count,hem:+e.hem,edge:+e.edge}))),nameIsPrefix:e.nameIsPrefix,rotate:e.rotate,cut:e.cut,showPartInName:e.showPartInName,getAllData:e.getAllData,prepareOutputPlates:e.prepareOutputPlates,axisX:e.axisX}};const s=function(e=8){return Math.random().toString(36).substr(2,e)};const n=function(e,t="w"){return t?e.sort(((e,a)=>a[t]-e[t])):e.sort(((e,t)=>t-e))};const i=function(e,t,a,r,i,o){let l=[],p=[];return e.forEach(((e,r)=>{for(let n=1;n<=e.count;n++){const l=e.name?`${i?t:""}${e.name}`:`${t} ${r+1}-${n}`,h=s(),E=Math.ceil(e.length/a),c=e.height,u=e.length%a||a,_=e.hem,m=e.edge,T=u>0&&u<o?o-u:0;for(let t=0,r=1;t<e.length;t+=a,r++){const t=1===r?u+T:2===r?a-T:a;p.push({...e,name:l,w:t,h:c,id:h,part:r,parts:E,hem:_,edge:m,rotate:!1})}}})),p=p.reduce(((e,t)=>(e[t.w]=e[t.w]?[...e[t.w],t]:[t],e)),{}),Object.keys(p).forEach((e=>p[e].length>1&&n(p[e],"h"))),n(Object.keys(p),!1).forEach((e=>l.push(...p[e]))),l};const o=function(e,t,a="floor"){if(!["round","ceil","floor"].find((e=>e===a)))throw new Error("mode is error");return Math[a](e/t)*t};const l=function(e,t,a,r,s=P(),i=!1){const o=a?t[s].size:t[s].length,l=[],p=a?t[s].height:t[s].size,h=t[s].matrix,E=t[s].spaceSymbol===r.startSpace?r.alternateSpace:r.startSpace,c=i?r.divide:r.rect,u=e-1>0?e-1:1;t[s].spaceSymbol=E;const _=(e,t)=>h[e][t]===r.rect||h[e][t]===c,m=(e,t,a,r)=>{let s=r;for(;s>1;){if(s=Math.ceil(s/2),e[t]!==e[t-1])return t;_(a,t)||e[t]!==e[t+1]?t+=s:t-=s}return t},T=(e,t)=>{let a=0,r=0;for(let r=t;r<p&&!_(r,e);r++)a++;for(let s=t-1;s>=0&&!_(s,e);s--)r++,a++;return{h:a,y:r}},g=(e,t,a)=>{let r=0;for(let s=e;s<o&&(!_(t,s)&&!_(t-a,s));s++)r++;return{w:r,x:0}};for(let e=0;e<p;e++)for(let t=0;t<o;t+=u)if(h[e][t]!==r.rect&&h[e][t]!==E&&h[e][t]!==c){t=m(h[e],t,e,u);const{h:a,y:r}=T(t,e),{w:n,x:i}=g(t,e,r);v({x:t-i,w:n,y:e-r,h:a,index:s,value:E}),l.push({x:t-i,y:e-r,w:n,h:a,fromPlate:s}),t+=n}return i?l:k(s,n(l))};const p=function(e,t,a,r,s,n){let i,o,l=e.length-1;const p=e[l]?.size||t;if(p===t){const e=Array.from(Array(r),(()=>new Array(a).fill(n)));d({length:a,height:r,items:[],matrix:e,size:t,unusedSpace:[{x:0,y:0,w:a,h:r}],spaceSymbol:s}),i=!0}else o=C(p,"ceil"),o===p&&o<t&&(o=C(p+1,"ceil")),f(l,o),i=!1;return i};const h=function(e,t,a,r,s){let n=0;const i=[];for(let o=e-t,l=a-1;o>=0;o-=t,l--){for(let e=0;e<y(r);e++){const t=L(r,e),a=t.rotate&&s||!t.rotate&&!s?t.h:t.w;(s?t.x:t.y)+a>o&&(i.push({...t}),v({x:t.x,w:t.w,y:t.y,h:t.h,rotate:t.rotate,value:0,index:r}),x(r,e),e--)}if(i.length)break;n++}return f(r,e-t*++n),!!i.length&&i};const E=function(e,t,a=!1){if("string"==typeof t&&!1===a)return void console.warn("props error");const r="string"==typeof t?t:t.name,s=new RegExp(`${e}.+$`);return e=`${e} ${!1===a?t.part:a}`,s.test(r)?r.replace(s,e):`${r} ${e}`};const c=function(e,t){return e>t&&(console.warn(`calculation aborted (iteration > ${t})`),!0)};const u=function(e,t,a){return Object.keys(e).forEach((r=>{const s=t.filter((e=>e.id===r)),n=e[r].parts-e[r].items+s.length;let i=0;console.log(e),s.forEach((e=>{e.part=++i,e.parts=n,a&&(e.name=Z(e))})),$(r,i,n)})),t};const _=function(e,t,a,r,s){let n=null,i=0,o=w()-1;for(;o>=0;){const l=F(o);if(l.length){const t=l.reduce(((e,t)=>(e[t.id]=e[t.id]?{parts:t.parts,items:e[t.id].items+1}:{parts:t.parts,items:1},e)),{}),p=()=>{const t=D(o);f(o,t+e,(()=>{let s=t,n=0,i=e,p=a;j("axisX")||([s,n,i,p]=[n,s,p,i]),v({x:s,y:n,w:i,h:p,value:r,index:o}),l.forEach((e=>A(o,e)))})),o--},h=()=>{n.forEach((e=>{A(e.fromPlate,e),b(e.fromPlate)}))};n=V(l.map((e=>({...e})))),!1===n?p():(n=u(t,n,s),h()),i=0,y(o<0?0:o)||(H(),o--)}if(++i,c(i,t))break}};const m=function(e,t,a,r){let s=0;for(;O();){let n=!1;const i=P();(r?C(R()):a)===a&&G();e:for(let t=0;t<U();t++){const a=z(t);for(let t=0;t<O();t++){const r=M(t),o=r.w<=a.w&&r.h<=a.h,l=r.w<=a.h&&r.h<=a.w;if(o||e&&l){const o={...r,x:a.x,y:a.y,w:r.w,h:r.h,fromPlate:i};e&&l&&!o.rotate&&(o.rotate=!0),A(i,o),X(t),b(),n=!0,s=0;break e}}if(t===U()-1&&y()){let e=!0;i===w()-1&&O()&&(e=S()),e&&!n&&I()}}if(++s,c(s,t))break}};const T=function(e){const s=t.getState(),c=s.config,u=()=>e.plate>=0?e.plate:s.currentIndexPlate;switch(e.type){case"INITIAL_STATE":return t.init();case"GET_STATE":return s;case"VALIDATE_CONFIG_DATA":return t.setState({errors:a(e.config)}),t.getErrors();case"PREPARE_CONFIG_DATA":return t.setState({config:r(e.config)});case"EXTRACT_PARTS":return t.setState({parts:i(c.parts,c.name,c.length,c.partName,c.nameIsPrefix,c.minPart)});case"CALC_SIZE":return t.setState({size:c.axisX?c.length:c.height});case"CALC_SIZE_STEP":return t.setState({sizeStep:s.size*c.step});case"CALC_COUNT_PART":return t.setState({countPart:Math.round(s.size/s.sizeStep)});case"GET_CONFIG_DATA":return c.hasOwnProperty(e.key)?c[e.key]:c;case"GET_CURRENT_SIZE":return s.size||null;case"ADD_STATISTIC":{if("object"!=typeof e.obj)throw new Error("object error");const a={...s.statistic,...e.obj};return t.setState({statistic:a})}case"IS_CUT":return c.cut;case"DIVIDER":return function(e,t,a,r,s,i,o,l){const p=[];let h=null;for(const E of i){let i,c=!1;const u=()=>{h=[];for(let t=0;t<e.length;t++)h.push(...b(t,!0));_()},_=()=>{h=n(h.filter((e=>e.h>=E.h&&e.w>=t||!!(a&&!e.rotate&&e.w>=E.h&&e.h>=t)&&([e.w,e.h]=[e.h,e.w],e.rotate=!0,!0)))),h.push({w:0})},m=e=>{e.forEach((e=>v({x:e.x,w:e.w,y:e.y,h:e.h,rotate:e.rotate,value:l,index:e.fromPlate})))},T=(e=Math.round(o/2))=>{let a=0,r=[];if(u(),r.length<i)for(let n=0;n<h.length-1;n++)if(!(a+h[n+1].w>E.w)){{const i=h[n],o=i.fromPlate;i.w=i.w>e?e:i.w,a+=i.w;let l=i.w-(a>E.w?a-E.w:0),p=E.h;if(l<t)for(let e=r.length-1;e>=0;e--){const a=r[e].w-(t-l);if(a>=t){r[e].w=a,l=t;break}if(l+=r[e].w-t,r[e].w=t,0===e)return!1}r.push({...E,x:i.x,y:i.y,w:l,h:p,fromPlate:i.fromPlate,rotate:i.rotate}),v({x:i.x,w:l,y:i.y,h:p,rotate:i.rotate,value:s,index:o});for(let e=0;e<h.length;e++)h[e].fromPlate===o&&(h.splice(e,1),e--);h.push(...b(o,!0)),_(),n=-1}if(a>=E.w||r.length===i)break}return a<E.w&&e<o?(m(r),T(o)):!(a<E.w)&&r};if(i=r+2-E.parts,E&&E.rotate&&(E.rotate=!1),c=T(),!1===c)return m(p),!1;p.push(...c)}return p}(s.plates,c.minPart,c.rotate,c.maxStack,s.symbols.divide,e.items,c.length,s.symbols.unusedSpace);case"BASIC_POSITIONING":return m(c.rotate,s.maxIteration,c.length,c.axisX);case"DIVISION_OF_PRODUCTS":return _(s.sizeStep,s.maxIteration,c.height,s.symbols.unusedSpace,s.config.showPartInName);case"PUSH_NEW_PLATE":return t.setState({plates:[...s.plates,e.plate]});case"CREATE_NEW_PLATE":return p(s.plates,s.size,c.length,c.height,s.symbols.startSpace,s.symbols.unusedSpace);case"CALC_CURRENT_SIZE":return o(e.size,s.sizeStep,e.mode);case"SET_NEW_SIZE_PLATE":{if("function"!=typeof e.cb)throw new Error("cb is not a function");const t=s.plates[e.plate].size=e.size;return e.cb(),b(e.plate),t}case"GET_CURRENT_INDEX_PLATE":return s.currentIndexPlate;case"FIND_UNUSED_SPACE":return l(c.minPart,s.plates,c.axisX,s.symbols,e.index,e.divideMode);case"GET_OPTIMIZATION_LEVEL":return c.optimization;case"GET_PARTS_LENGTH":return s.parts.length;case"GET_PART_ITEM":return{...s.parts[e.item]};case"GET_MAX_X1":return Math.max(...s.plates[u()].items.map((e=>e.x+e.w)),0);case"GET_USED_PARTS":{let t;if(s.plates[e.plate].size===s.size){let a=0;s.plates[e.plate].unusedSpace.forEach((e=>{s.axisX&&e.h===c.height&&a<e.x?a=e.x:!s.axisX&&e.w===c.width&&a<e.y&&(a=e.y)})),t=C(0===a?s.size:a,"ceil")}else t=s.plates[e.plate].size;return Math.round(t/s.sizeStep)}case"REVERSE_UNUSED_SPACE":return s.plates[u()].unusedSpace.reverse();case"GET_UNUSED_SPACE_LENGTH":return s.plates[u()].unusedSpace.length;case"GET_UNUSED_SPACE_ITEM":return{...s.plates[u()].unusedSpace[e.item]};case"ADD_ITEM_TO_PLATE":{const{x:t,w:a,y:r,h:n,rotate:i,fromPlate:o}=e.item;return v({x:t,w:a,y:r,h:n,rotate:i,index:o}),s.plates[e.plateIdx].items.push(e.item)}case"CHANGE_ITEM_TO_PLATE":return["x","w","y","h","rotate","fromPlate","id","height","length","count","part","parts","name","hem","edge"].forEach((t=>{e.data.hasOwnProperty(t)&&(delete e.data[t],console.warn(`key ${t} is forbidden`))})),s.plates[e.plateIdx].items[e.item]={...s.plates[e.plateIdx].items[e.item],...e.data};case"FILL_RECT":{let{x:t,y:a,w:r,h:n,index:i=s.currentIndexPlate,value:o=1,rotate:l=!1}=e.param;l&&([r,n]=[n,r]);for(let e=t;e<r+t;e++)for(let t=a;t<n+a;t++)s.plates[i].matrix[t][e]=o;return}case"DELETE_PART_ITEM":return s.parts.splice(e.index,1);case"GET_PLATE_ITEMS_LENGTH":return s.plates[u()].items.length;case"GET_PLATES_LENGTH":return s.plates.length;case"NEXT_INDEX_PLATE":return++s.currentIndexPlate;case"SET_NEW_UNUSED_SPACE":return s.plates[u()].unusedSpace=e.value;case"GET_PLATE_ITEM":return{...s.plates[e.plateIdx].items[e.itemIdx]};case"DELETE_PLATE_ITEM":return s.plates[e.plateIdx].items.splice(e.itemIdx,1);case"GET_PLATE_SIZE":return s.plates[e.plateIdx].size;case"SELECT_ITEMS_OF_LAST_PART":return h(s.size,s.sizeStep,s.countPart,e.index,c.axisX);case"UPDATE_PART_NAME":return E(c.partName,e.partItemOrName,e.part);case"DELETE_LAST_PLATE":return s.plates.splice(-1);case"UPDATE_PARTS_INFO_IN_PLATE":{let t=e.startPart;e:for(let a in s.plates)for(let r in s.plates[a].items){const n=s.plates[a].items[r];if(n.id===e.id&&(++t,s.config.showPartInName&&(n.name=Z(n,t)),n.part=t,n.parts=e.parts,t===e.parts))break e}return}case"REMOVE_NOT_NEEDED_IN_PLATE":return s.plates=s.plates.map((e=>e.items));case"GET_UNUSED_PARTS_OF_PLATE":{const t=Math.max(...s.plates[e.plateIndex].items.map((e=>c.axisX?e.x+e.w:e.y+e.h)));return C(t,"ceil")}}},g=()=>T({type:"GET_STATE"}),P=()=>T({type:"GET_CURRENT_INDEX_PLATE"}),I=()=>T({type:"NEXT_INDEX_PLATE"}),S=()=>T({type:"CREATE_NEW_PLATE"}),d=e=>T({type:"PUSH_NEW_PLATE",plate:e}),f=(e,t,a=(()=>{}))=>T({type:"SET_NEW_SIZE_PLATE",plate:e,size:t,cb:a}),A=(e,t)=>T({type:"ADD_ITEM_TO_PLATE",plateIdx:e,item:t}),N=(e,t,a)=>T({type:"CHANGE_ITEM_TO_PLATE",plateIdx:e,item:t,data:a}),x=(e,t)=>T({type:"DELETE_PLATE_ITEM",plateIdx:e,itemIdx:t}),y=e=>T({type:"GET_PLATE_ITEMS_LENGTH",plate:e}),w=()=>T({type:"GET_PLATES_LENGTH"}),L=(e,t)=>T({type:"GET_PLATE_ITEM",plateIdx:e,itemIdx:t}),D=e=>T({type:"GET_PLATE_SIZE",plateIdx:e}),C=(e,t)=>T({type:"CALC_CURRENT_SIZE",size:e,mode:t}),b=(e,t)=>T({type:"FIND_UNUSED_SPACE",index:e,divideMode:t}),O=()=>T({type:"GET_PARTS_LENGTH"}),R=e=>T({type:"GET_MAX_X1",plate:e}),G=e=>T({type:"REVERSE_UNUSED_SPACE",plate:e}),U=e=>T({type:"GET_UNUSED_SPACE_LENGTH",plate:e}),z=(e,t)=>T({type:"GET_UNUSED_SPACE_ITEM",plate:t,item:e}),M=e=>T({type:"GET_PART_ITEM",item:e}),v=e=>T({type:"FILL_RECT",param:e}),X=e=>T({type:"DELETE_PART_ITEM",index:e}),k=(e,t)=>T({type:"SET_NEW_UNUSED_SPACE",plate:e,value:t}),F=e=>T({type:"SELECT_ITEMS_OF_LAST_PART",index:e}),Z=(e,t)=>T({type:"UPDATE_PART_NAME",partItemOrName:e,part:t}),$=(e,t,a)=>T({type:"UPDATE_PARTS_INFO_IN_PLATE",id:e,startPart:t,parts:a}),H=()=>T({type:"DELETE_LAST_PLATE"}),V=e=>T({type:"DIVIDER",items:e}),j=e=>T({type:"GET_CONFIG_DATA",key:e}),W=e=>T({type:"GET_USED_PARTS",plate:e});function B(e){const t=(new Date).getTime(),a={name:"name",partName:"part",nameIsPrefix:!1,rotate:!1,cut:!1,showPartInName:!0,parts:[],length:3660,height:760,step:.25,minPart:12,maxStack:1,optimization:2,prepareOutputPlates:!0,getAllData:!1,axisX:!0,...e};T({type:"INITIAL_STATE"});let r=T({type:"VALIDATE_CONFIG_DATA",config:a});if(r.length)return r;if(r=null,(e=>{T({type:"PREPARE_CONFIG_DATA",config:e})})(a),T({type:"EXTRACT_PARTS"}),T({type:"CALC_SIZE"}),T({type:"CALC_SIZE_STEP"}),T({type:"CALC_COUNT_PART"}),S(),T({type:"BASIC_POSITIONING"}),T({type:"IS_CUT"}))for(let e=0;e<T({type:"GET_OPTIMIZATION_LEVEL"});e++){for(let e=0;e<w()-1;e++){const t=T({type:"GET_CURRENT_SIZE"});D(e)<t&&f(e,t)}T({type:"DIVISION_OF_PRODUCTS"})}else for(let e=0;e<w();e++)f(e,T({type:"GET_UNUSED_PARTS_OF_PLATE",plateIndex:e}));let s=0,n=0,i=w(),o=0,l={element:0,base:0,hem:0,edge:0},p={element:0,base:0,hem:0,edge:0};g().config.parts.forEach((e=>{const t=e.length*e.count,a=2*e.count;l.element+=t*e.height,l.base+=t*(e.height-e.hem-e.edge),l.hem+=t*e.hem,l.edge+=t*e.edge,p.element+=(e.length+e.height)*a,p.base+=(e.length+(e.height-e.hem-e.edge))*a,p.hem+=e.hem?(e.length+e.hem)*a:0,p.edge+=e.edge?(e.length+e.edge)*a:0}));for(let e=0;e<i;e++){const t=W(e);s+=t,n+=t*g().sizeStep,o+=t*g().config.step;for(let t=0;t<y(e);t++){const a=L(e,t);N(e,t,{area:{product:{element:a.length*a.height,base:a.length*(a.height-a.hem-a.edge),hem:a.length*a.hem,edge:a.length*a.edge},part:{element:a.w*a.h,base:a.w*(a.h-a.hem-a.edge),hem:a.w*a.hem,edge:a.w*a.edge}},perimeter:{product:{element:2*(a.length+a.height),base:2*(a.length+(a.height-a.hem-a.edge)),hem:a.hem?2*(a.length+a.hem):0,edge:a.edge?2*(a.length+a.edge):0},part:{element:2*(a.w+a.h),base:2*(a.w+(a.h-a.hem-a.edge)),hem:a.hem?2*(a.w+a.hem):0,edge:a.edge?2*(a.w+a.edge):0}}})}}var h;return h={countOfParts:s,totalLength:n,countOfPlates:i,countPartsInPlates:o,perimeter:p,area:l,time:.001*((new Date).getTime()-t)},T({type:"ADD_STATISTIC",obj:h}),j("prepareOutputPlates")&&T({type:"REMOVE_NOT_NEEDED_IN_PLATE"}),j("getAllData")?g():{config:j(),plates:g().plates,statistic:g().statistic,countPart:g().countPart,mainSize:g().size,errors:g().errors,sizeStep:g().sizeStep}}self.onmessage=function(e){const t=B(e.data);self.postMessage(t)};